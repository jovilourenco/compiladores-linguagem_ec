// TESTE FUN B — Resto (%) e par/ímpar

fun ehImpar(n) {
  var r = 0;
  if ((n % 2) == 1) {
    r = 1;
  } else {
    r = 0;
  }
  return r;
}
main {
  return ehImpar(5);
}
*** Esperado: imprime 1. Testa operador % (resto). ***

// TESTE FUN C — Soma acumulada com += e incremento pós-fixado

fun soma_ate(n) {
  var i = 0;
  var s = 0;
  while (i < n) {
  s += i;
  i++;
  }
  return s;
}
main {
  return soma_ate(5);
}
*** Esperado: imprime 10 (1+2+3+4). Testa += e i++. ***

// TESTE FUN D — Incremento pós-fixado em parâmetro (efeito local)

fun inc_param(n) {
  n++;
  return n;
}
main {
  return inc_param(5);
}
*** Esperado: imprime 6. Testa n++ sobre parâmetro (efeito local). ***

// TESTE FUN E — Decremento pós-fixado

fun decParam(n) {
  n--;
  return n;
}
main {
  return decParam(5);
}
*** Esperado: imprime 4. Testa n--. ***

// TESTE FUN F — Operadores compostos (*=) e chamadas encadeadas

fun mult2(n) {
  n *= 2;
  return n;
}
fun add_and_double(a,b) {
  var t = a + b;
  return mult2(t);
}
main {
  return add_and_double(3,4);
}
*** Esperado: imprime 14. Testa *= e chamada encadeada. ***

// TESTE FUN G — Erro semântico: += em variável não declarada

fun broken() {
  x += 1;
  return 0;
}
main {
  return broken();
}
*** Esperado: ERRO SEMÂNTICO — atribuição composta para 'x' não declarada no escopo da função. ***

// TESTE FUN I — Resto por zero (erro em tempo de execução)

fun divzero(n) {
  var r = 0;
  r = n % 0;
  return r;
}
main {
  return divzero(5);
}
*** Esperado: ERRO em tempo de execução — divisão por zero (ZeroDivisionError). ***

// TESTE FUN J — Globais e incremento em função (modifica global)

var g = 1;
fun incg() {
  g++;
  return g;
}
main {
  return incg();
}
*** Esperado: imprime 2. Testa acesso e modificação de variável global dentro da função. ***

// TESTE FUN K — Comp compound assignment com leitura/escrita em locais e parâmetros

fun mix(a) {
  var x = 2;
  x += a; 
  a *= 3; 
  return x + a;
}
main {
  return mix(4);
}
*** Esperado: imprime 2+4 + 4*3 = 6 + 12 = 18. Testa += e *= com parâmetros e locais. ***

// TESTE FUN L — Complexidade: recursão + resto + compostos

fun f(n) {
  var r = 0;
  if (n < 2) {
    r = n;
  } else {
    r = (n % 2) + f(n - 1);
  }
  return r;
}
main {
  return f(5);
}
*** Exemplo de recursão funcionando normalmente com operadores adicionados ***

// TESTE FUN M — Teste de ordem/forward (chamada para função definida depois)

fun caller(n) {
  return callee(n - 1);
}
fun callee(n) {
  if (n < 0) { return 0; }
  return n;
}
main {
  return caller(3);
}
*** Função chamada antes da declaração, mas como ele lê tudo até o main, ele já leu callee, então, funciona normalmente. ***

// TESTE FUN N — Teste complexo com ++/-- e atribuicoes compostas aninhadas

fun complex(n) {
  var a = 1;
  var b = 2;
  a += n;
  b = a;
  b--;
  a++;
  return a + b;
}
main {
  return complex(3);
}
*** Esperado: a = 1+3 = 4; b = 4; b-- -> 3; a++ -> 5; retorno = 5+3 = 8. ***

// TESTE FUN O — Função sem parâmetros (retorno constante)

fun cinco() {
  return 5;
}
main {
  return cinco();
}
*** Esperado: imprime 5. Teste de função sem parâmetros. ***

// TESTE FUN Q — Teste de segurança: uso de ++ em expressão

fun tryExpr(n) {
  var r = 0;
  r = n++ ;
  return r;
}
main {
  return tryExpr(5);
}
*** SYNTAX_ERROR pois n++ só permitido como statement. ***

// TESTE FUN R — Exemplo simples (maioridade)

fun maioridade(n){
  var x = 0;
  if (n >= 18){
    x = 1;
  } else {
    x = 0;
  }
  return x;
}
main {
  return maioridade(20);
}
*** Esperado: imprime 1. Mesmo que o primeiro teste (A), mantido para referência. ***